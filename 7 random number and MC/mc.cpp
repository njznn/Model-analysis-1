


using namespace std;
#include <chrono>
#include <omp.h>

# define PI           3.14159265358979323846
#include <fstream>
using std::ofstream;
#include <random>
#include <iostream>

using namespace std::chrono;

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    std::default_random_engine gen (seed);

    std::uniform_real_distribution<double> dis(0.0,1.0);
    unsigned seed1 = std::chrono::system_clock::now().time_since_epoch().count();
    std::default_random_engine gen1 (seed1);

    std::uniform_real_distribution<> dis1(0.0, 1.0);
    unsigned seed2 = std::chrono::system_clock::now().time_since_epoch().count();
    std::default_random_engine gen2 (seed2);

    std::uniform_real_distribution<> dis2(0.0, 1.0);

    std::vector<double> t = {0.022, 0,131,1,374, 14.92 ,144.75, 1452};
    std::vector<double> tp = {0.028,0.096 , 1.00, 11.42,104.4, 1075.79 };
    //10^5 do 10^10
    long double n=0;
    long double A=0;
    long double N = 10000000000;
    long double  meja = N+1;
    int j = 0;

    size_t i;
    double x,y,z;

    auto start = high_resolution_clock::now();
    //#pragma omp parallel for reduction(+:n,A)

    for (long i = 1; i < (meja); ++i) {
      x = dis(gen);
      y = dis1(gen1);
      z = dis2(gen2);

      //if (i%100000 == 0){
        //vec_N(j)=N;
        //vec_vol(j)=8*n/N;
        //j++;
      //}
      if ((sqrt(x) +sqrt(y)+sqrt(z)) < 1 ){
        n++;
      }

        // Use dis to transform the random unsigned int generated by gen into a
      A++;  // double in [1, 2). Each call to dis(gen) generates a new random doubl
      }



    //std::cout << N << '\n';
    std::cout << n << '\n';
    std::cout << A << '\n';
    auto stop = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(stop - start);
    std::cout << 8* n/ A << '\n';
    std::cout << (double) duration.count()/1000 << '\n';
}
